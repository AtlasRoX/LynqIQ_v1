"use client"

import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { FileText, Download, Loader2, Sparkles, AlertTriangle } from "lucide-react"
import { useState } from "react"
import type { Sale, Cost, Product, Customer, DashboardMetrics, AIInsight } from "@/lib/types" // Import AIInsight
import jsPDF from "jspdf"
import autoTable from "jspdf-autotable"
import { Textarea } from "@/components/ui/textarea"
// --- Using the local insights function to avoid API errors ---
import { generateLocalAIInsights } from "@/lib/ai-insights-local"
// We need this for the full metrics type, but it's not directly in this file
// import { calculateMetrics } from "@/lib/analytics-utils" 

interface ReportGeneratorProps {
  timeFrame: string
  sales: Sale[]
  costs: Cost[]
  products: Product[]
  customers: Customer[]
  metrics: DashboardMetrics
  // --- NEW: Added businessName prop ---
  businessName: string
}

// --- Casting metrics to 'any' to access all properties from analytics-utils ---
type Metrics = DashboardMetrics & {
  topCustomers?: any[]
  profitPerProduct?: any[]
  worstSellingProducts?: Product[]
  salesByCategory?: Record<string, number>
  salesByChannel?: Record<string, number>
  profitPerCategory?: Record<string, number> // Added for more detail
}

export function ReportGenerator({ 
  timeFrame, 
  sales, 
  costs, 
  products, 
  customers, 
  metrics: rawMetrics,
  // --- NEW: Destructure businessName ---
  businessName 
}: ReportGeneratorProps) {
  const [pdfLoading, setPdfLoading] = useState(false)
  const [summaryLoading, setSummaryLoading] = useState(false)
  const [aiSummary, setAiSummary] = useState("")
  const [aiError, setAiError] = useState("")
  
  const metrics = rawMetrics as Metrics

  // --- HELPER: Formats to Taka (BDT) ---
  const formatTaka = (amount: number) => {
    if (typeof amount !== 'number' || isNaN(amount)) {
      amount = 0;
    }
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "BDT",
      minimumFractionDigits: 0,
    }).format(amount)
  }
  
  // --- HELPER: Formats a number with commas ---
  const formatNum = (num: number) => {
    if (typeof num !== 'number' || isNaN(num)) {
      num = 0;
    }
    return new Intl.NumberFormat("en-US").format(num);
  }

  // --- Step 1: Generate Local Summary ---
  const handleGenerateSummary = async () => {
    setSummaryLoading(true)
    setAiError("")
    setAiSummary("")
    try {
      const localInsights: AIInsight[] = generateLocalAIInsights(sales, costs, products, customers);
      
      if (!localInsights || localInsights.length === 0) {
        throw new Error("No local insights could be generated. Check your data.");
      }

      // Format the insights into a readable string for the textarea
      const summaryText = localInsights
        .map(insight => `[${insight.impact.toUpperCase()} ${insight.category.toUpperCase()}] ${insight.title}:\n${insight.description}`)
        .join("\n\n");

      setAiSummary(summaryText);

    } catch (error: any) {
      console.error("Error generating local summary:", error)
      setAiError(error.message) 
    } finally {
      setSummaryLoading(false)
    }
  }
  
  // --- Step 2: Generate Premium PDF ---
  const generatePDF = () => {
    setPdfLoading(true)
    try {
      const doc = new jsPDF()
      const pageHeight = doc.internal.pageSize.height
      const pageWidth = doc.internal.pageSize.width
      const pageMargin = 20 // Use 20mm margins
      let cursor = 0

      // --- Design Constants ---
      const COLOR_PRIMARY = "#198754" // Brand Primary (from globals.css)
      const COLOR_TEXT = "#222222"
      const COLOR_SUBTEXT = "#666666"
      const COLOR_BACKGROUND = "#F8F9FA" // Light Gray (from globals.css)
      const COLOR_BORDER = "#DEE2E6"
      const FONT_BODY = "Helvetica" // Use built-in sans-serif
      const FONT_BOLD = "Helvetica-Bold"

      // --- Helper: Add Footer & Page Number ---
      const addPageFooter = (docInstance: jsPDF) => {
        const pageCount = (docInstance.internal as any).pages.length - 1;
        for (let i = 1; i <= pageCount; i++) {
          docInstance.setPage(i);
          // Skip footer on cover page
          if (i === 1) continue; 
          
          docInstance.setFont(FONT_BODY, "normal");
          docInstance.setFontSize(9);
          docInstance.setTextColor(COLOR_SUBTEXT);
          
          const footerY = pageHeight - 15;
          docInstance.setDrawColor(COLOR_BORDER);
          docInstance.line(pageMargin, footerY - 5, pageWidth - pageMargin, footerY - 5);
          
          docInstance.text(
            "Generated by LynqIQ – The SME Business Intelligence Suite",
            pageMargin,
            footerY
          );
          docInstance.text(
            `© ${new Date().getFullYear()} LynqIQ. All Rights Reserved. | Page ${i} of ${pageCount}`,
            pageWidth - pageMargin,
            footerY,
            { align: "right" }
          );
        }
      };

      // --- Helper: Add Section Header ---
      const addSectionHeader = (title: string, y: number) => {
        doc.setFont(FONT_BOLD, "normal");
        doc.setFontSize(16);
        doc.setTextColor(COLOR_TEXT);
        doc.text(title, pageMargin, y);
        doc.setDrawColor(COLOR_PRIMARY);
        doc.setLineWidth(0.5);
        doc.line(pageMargin, y + 2, pageWidth - pageMargin, y + 2);
        return y + 10;
      };

      // --- Helper: Check for page break ---
      const checkPageBreak = (currentCursor: number, requiredHeight: number) => {
        if (currentCursor + requiredHeight > pageHeight - 30) {
          doc.addPage();
          cursor = pageMargin + 10; // Reset cursor for new page
          return cursor;
        }
        return currentCursor;
      };

      // === 1. COVER PAGE =============================================
      doc.setFillColor(COLOR_BACKGROUND);
      doc.rect(0, 0, pageWidth, pageHeight, "F");

      doc.setFont(FONT_BOLD, "normal");
      doc.setFontSize(20);
      doc.setTextColor(COLOR_PRIMARY);
      doc.text("LynqIQ", pageMargin, 40);

      doc.setFont(FONT_BOLD, "normal");
      doc.setFontSize(24);
      doc.setTextColor(COLOR_TEXT);
      doc.text("BUSINESS PERFORMANCE REPORT", pageWidth / 2, 120, { align: "center" });

      doc.setFont(FONT_BODY, "normal");
      doc.setFontSize(12);
      doc.setTextColor(COLOR_SUBTEXT);
      const metaY = pageHeight - 60;
      
      // --- FIX 1: Use businessName prop ---
      doc.text(businessName || "Your Business", pageWidth - pageMargin, metaY, { align: "right" });
      
      doc.text(`Report Period: ${timeFrame}`, pageWidth - pageMargin, metaY + 7, { align: "right" });
      doc.text(`Generated On: ${new Date().toLocaleString('en-US')}`, pageWidth - pageMargin, metaY + 14, { align: "right" });
      doc.text("Generated By: LynqIQ System", pageWidth - pageMargin, metaY + 21, { align: "right" });


      // === 2. EXECUTIVE SUMMARY ======================================
      doc.addPage();
      cursor = pageMargin + 10;
      cursor = addSectionHeader("EXECUTIVE SUMMARY", cursor);

      const execMetrics = [
        ["Total Revenue", formatTaka(metrics.totalRevenue)],
        ["Total Costs", formatTaka(metrics.totalExpenses)],
        ["Profit", formatTaka(metrics.netProfit)],
        ["Profit Margin", `${metrics.profitMargin.toFixed(1)}%`],
        ["ROI", `${metrics.roi.toFixed(1)}%`],
        ["Health Score", `${metrics.healthScore}/100`],
      ];

      autoTable(doc, {
        startY: cursor,
        body: execMetrics,
        theme: 'plain',
        styles: { font: FONT_BODY, fontSize: 11 },
        columnStyles: {
          0: { font: FONT_BOLD, cellWidth: 50 },
          1: { halign: 'right', font: FONT_BODY }
        },
        didDrawPage: (data) => { cursor = data.cursor?.y || cursor; }
      });
      
      cursor += 5;
      
      // Mini Bar Chart
      doc.setFont(FONT_BODY, "normal");
      doc.setFontSize(10);
      doc.setTextColor(COLOR_SUBTEXT);
      doc.text("Profit vs. Cost", pageMargin, cursor);
      cursor += 5;
      const chartMax = Math.max(metrics.netProfit, metrics.totalExpenses, 1);
      const chartWidth = pageWidth - pageMargin * 2;
      
      // Cost Bar
      doc.setFillColor(COLOR_SUBTEXT);
      doc.rect(pageMargin, cursor, (metrics.totalExpenses / chartMax) * chartWidth, 10, "F");
      doc.text("Cost", pageMargin + 2, cursor + 7);
      cursor += 12;
      
      // Profit Bar
      doc.setFillColor(COLOR_PRIMARY);
      doc.rect(pageMargin, cursor, (metrics.netProfit / chartMax) * chartWidth, 10, "F");
      doc.text("Profit", pageMargin + 2, cursor + 7);
      cursor += 20;
      

      // === 3. FINANCIAL OVERVIEW =====================================
      cursor = checkPageBreak(cursor, 120);
      cursor = addSectionHeader("FINANCIAL OVERVIEW", cursor);

      // --- Data Prep: Revenue Breakdown ---
      const totalRevenue = metrics.totalRevenue || 1; // Avoid divide by zero
      const revenueData = Object.entries(metrics.salesByChannel || {}).map(([source, amount]) => [
        source,
        formatTaka(amount),
        `${((amount / totalRevenue) * 100).toFixed(1)}%`
      ]);
      
      doc.setFont(FONT_BOLD, "normal");
      doc.setFontSize(12);
      doc.text("a) Revenue Breakdown by Channel", pageMargin, cursor);
      cursor += 6;

      autoTable(doc, {
        startY: cursor,
        head: [["Source", "Amount", "% of Total"]],
        body: revenueData,
        theme: 'striped',
        headStyles: { fillColor: COLOR_PRIMARY },
        didDrawPage: (data) => { cursor = data.cursor?.y || cursor; }
      });
      cursor += 10;
      
      // --- Data Prep: Expense Breakdown ---
      cursor = checkPageBreak(cursor, 100);
      const totalExpenses = metrics.totalExpenses || 1;
      const costByCategory = costs.reduce((acc, cost) => {
        acc[cost.category] = (acc[cost.category] || 0) + cost.amount;
        return acc;
      }, {} as Record<string, number>);
      
      const expenseData = Object.entries(costByCategory).map(([category, amount]) => [
        category,
        formatTaka(amount),
        `${((amount / totalExpenses) * 100).toFixed(1)}%`
      ]);

      doc.setFont(FONT_BOLD, "normal");
      doc.setFontSize(12);
      doc.text("b) Expense Breakdown by Category", pageMargin, cursor);
      cursor += 6;
      
      autoTable(doc, {
        startY: cursor,
        head: [["Category", "Amount", "% of Total"]],
        body: expenseData,
        theme: 'striped',
        headStyles: { fillColor: COLOR_PRIMARY },
        didDrawPage: (data) => { cursor = data.cursor?.y || cursor; }
      });
      cursor += 10;


      // === 4. CUSTOMER INSIGHTS ======================================
      doc.addPage();
      cursor = pageMargin + 10;
      cursor = addSectionHeader("CUSTOMER INSIGHTS", cursor);

      const returningCustomers = customers.filter(c => c.total_orders > 1).length;
      const customerMetrics = [
        ["Total Customers", formatNum(metrics.totalCustomers)],
        ["Returning Customers", `${formatNum(returningCustomers)} (${(metrics.retentionRate || 0).toFixed(1)}%)`],
        ["Average Order Value (AOV)", formatTaka(metrics.aov)],
        ["Top 3 Customers", metrics.topCustomers.slice(0, 3).map(c => c.name).join(', ') || 'N/A']
      ];
      
      autoTable(doc, {
        startY: cursor,
        head: [["Metric", "Value"]],
        body: customerMetrics,
        theme: 'striped',
        headStyles: { fillColor: COLOR_PRIMARY },
        didDrawPage: (data) => { cursor = data.cursor?.y || cursor; }
      });
      cursor += 10;

      // --- Customer Pie Chart (Replaced with text legend to fix 'arc' error) ---
      doc.setFont(FONT_BOLD, "normal");
      doc.setFontSize(12);
      doc.text("New vs. Returning Customers", pageMargin, cursor);
      cursor += 8; // Add space
      
      const newCustomers = metrics.totalCustomers - returningCustomers;
      
      if (metrics.totalCustomers > 0) {
        doc.setFontSize(10);
        doc.setFillColor(COLOR_BORDER);
        doc.rect(pageMargin, cursor, 3, 3, "F");
        doc.text(`New Customers: ${formatNum(newCustomers)}`, pageMargin + 5, cursor + 2.5);
        cursor += 7;
        doc.setFillColor(COLOR_PRIMARY);
        doc.rect(pageMargin, cursor, 3, 3, "F");
        doc.text(`Returning Customers: ${formatNum(returningCustomers)}`, pageMargin + 5, cursor + 2.5);
      } else {
        doc.setFontSize(10);
        doc.setTextColor(COLOR_SUBTEXT);
        doc.text("No customer data for chart.", pageMargin, cursor);
      }
      cursor += 10;


      // === 5. PRODUCT PERFORMANCE =====================================
      doc.addPage();
      cursor = pageMargin + 10;
      cursor = addSectionHeader("PRODUCT PERFORMANCE", cursor);
      
      const productPerformance = products.map(p => {
        const pSales = sales.filter(s => s.product_id === p.id && s.status === 'completed');
        const unitsSold = pSales.reduce((sum, s) => sum + s.quantity, 0);
        const revenue = pSales.reduce((sum, s) => sum + s.total_amount, 0);
        const cost = unitsSold * p.cost_price;
        const profit = revenue - cost;
        const margin = revenue > 0 ? (profit / revenue) * 100 : 0;
        return { name: p.name, unitsSold, revenue, cost, profit, margin };
      }).sort((a, b) => b.revenue - a.revenue);
      
      autoTable(doc, {
        startY: cursor,
        head: [["Product", "Units Sold", "Revenue", "Cost", "Profit", "Margin"]],
        body: productPerformance.map(p => [
          p.name,
          formatNum(p.unitsSold),
          formatTaka(p.revenue),
          formatTaka(p.cost),
          formatTaka(p.profit),
          `${p.margin.toFixed(1)}%`
        ]),
        theme: 'striped',
        headStyles: { fillColor: COLOR_PRIMARY },
        didDrawPage: (data) => { cursor = data.cursor?.y || cursor; }
      });
      cursor += 10;
      
      // Top 5 Products Bar Chart
      // --- FIX: This check ensures the chart doesn't split awkwardly ---
      // (The original code was correct, this just confirms it)
      // Required height: 12 (title) + 8 (padding) + (5 items * 12 height) = 80.
      cursor = checkPageBreak(cursor, 100); 
      
      doc.setFont(FONT_BOLD, "normal");
      doc.setFontSize(12);
      doc.text("Top 5 Products by Revenue", pageMargin, cursor);
      cursor += 8;
      
      const top5Products = productPerformance.slice(0, 5);
      const maxRevenue = Math.max(...top5Products.map(p => p.revenue), 1);
      const productChartWidth = (pageWidth - pageMargin * 2) - 120;
      
      for (const product of top5Products) {
        const barWidth = (product.revenue / maxRevenue) * productChartWidth;
        doc.setFontSize(9);
        doc.setTextColor(COLOR_TEXT);
        doc.text(product.name, pageMargin, cursor + 5.5, { maxWidth: 70 });
        
        doc.setFillColor(COLOR_BORDER);
        doc.roundedRect(pageMargin + 75, cursor, productChartWidth, 8, 3, 3, "F");
        doc.setFillColor(COLOR_PRIMARY);
        doc.roundedRect(pageMargin + 75, cursor, barWidth, 8, 3, 3, "F");
        
        doc.setTextColor(COLOR_SUBTEXT);
        doc.text(formatTaka(product.revenue), pageMargin + 75 + barWidth + 5, cursor + 5.5);
        
        cursor += 12;
      }
      cursor += 10;
      

      // === 7. PERFORMANCE DASHBOARD (Skipping 6, already done) ======
      cursor = checkPageBreak(cursor, 100);
      cursor = addSectionHeader("PERFORMANCE DASHBOARD", cursor);
      
      // --- FIX 2: Replaced emojis with text for "Status" ---
      const kpiData = [
        ["Revenue Growth", "N/A", "N/A", "N/A"], // Growth is hard to calculate without context
        ["Customer Retention", `${metrics.retentionRate.toFixed(1)}%`, "85%", metrics.retentionRate > 85 ? "Good" : "Warning"],
        ["ROI", `${metrics.roi.toFixed(1)}%`, "100%", metrics.roi > 100 ? "Good" : (metrics.roi > 0 ? "Warning" : "Poor")],
        ["Avg. Order Value", formatTaka(metrics.aov), "N/A", "N/A"]
      ];

      autoTable(doc, {
        startY: cursor,
        head: [["KPI", "Current", "Target", "Status"]],
        body: kpiData,
        theme: 'grid',
        headStyles: { fillColor: COLOR_PRIMARY },
        didDrawPage: (data) => { cursor = data.cursor?.y || cursor; }
      });
      cursor += 10;
      

      // === 8. MONTHLY OVERVIEW =======================================
      doc.addPage();
      cursor = pageMargin + 10;
      cursor = addSectionHeader("MONTHLY OVERVIEW", cursor);

      // --- Monthly Data Prep ---
      const monthlyAgg: Record<string, { revenue: number, cost: number, profit: number }> = {};
      sales.forEach(s => {
        if (s.status !== 'completed') return;
        const month = s.date.slice(0, 7); // YYYY-MM
        if (!monthlyAgg[month]) monthlyAgg[month] = { revenue: 0, cost: 0, profit: 0 };
        monthlyAgg[month].revenue += s.total_amount;
        const product = products.find(p => p.id === s.product_id);
        const costOfSale = product ? product.cost_price * s.quantity : 0;
        monthlyAgg[month].cost += costOfSale;
      });
      costs.forEach(c => {
        const month = c.date.slice(0, 7);
        if (!monthlyAgg[month]) monthlyAgg[month] = { revenue: 0, cost: 0, profit: 0 };
        monthlyAgg[month].cost += c.amount;
      });

      let lastMonthProfit = 0;
      const monthlyTableData = Object.keys(monthlyAgg).sort().map(month => {
        const data = monthlyAgg[month];
        data.profit = data.revenue - data.cost;
        const growth = lastMonthProfit !== 0 ? ((data.profit - lastMonthProfit) / Math.abs(lastMonthProfit)) * 100 : 0;
        lastMonthProfit = data.profit;
        return [month, formatTaka(data.revenue), formatTaka(data.cost), formatTaka(data.profit), `${growth.toFixed(1)}%`];
      });

      autoTable(doc, {
        startY: cursor,
        head: [["Month", "Revenue", "Cost", "Profit", "Growth %"]],
        body: monthlyTableData,
        theme: 'striped',
        headStyles: { fillColor: COLOR_PRIMARY },
        didDrawPage: (data) => { cursor = data.cursor?.y || cursor; }
      });
      cursor += 10;


      // === 9. INSIGHTS & RECOMMENDATIONS =============================
      cursor = checkPageBreak(cursor, 120);
      cursor = addSectionHeader("INSIGHTS & RECOMMENDATIONS", cursor);
      
      const localInsights = generateLocalAIInsights(sales, costs, products, customers);
      doc.setFont(FONT_BODY, "normal");
      doc.setFontSize(10);
      
      for (const insight of localInsights.slice(0, 5)) { // Show top 5
        
        // --- FIX 3: Replaced emojis with text ---
        const icon = insight.category === 'risk' ? '(Risk)' : (insight.category === 'opportunity' ? '(Opportunity)' : '(Info)');
        const title = `${icon} [${insight.impact.toUpperCase()}] ${insight.title}`;
        const desc = insight.description;

        // --- FIX 3: Calculate full height *before* checking page break ---
        doc.setFont(FONT_BODY, "normal");
        doc.setFontSize(10);
        const splitDesc = doc.splitTextToSize(desc, pageWidth - pageMargin * 2 - 5);
        // 6 (for title) + 5 (padding) + (lines * 5 height per line)
        const requiredHeight = 6 + 5 + (splitDesc.length * 5); 

        cursor = checkPageBreak(cursor, requiredHeight); // Check for the *entire block*

        // Render Title
        doc.setFont(FONT_BOLD, "normal");
        doc.setFontSize(10); // Ensure font size is set
        doc.setTextColor(COLOR_TEXT);
        doc.text(title, pageMargin, cursor);
        cursor += 6;
        
        // Render Description
        doc.setFont(FONT_BODY, "normal");
        doc.setFontSize(10); // Ensure font size is set
        doc.setTextColor(COLOR_SUBTEXT);
        doc.text(splitDesc, pageMargin + 5, cursor);
        cursor += splitDesc.length * 5 + 5; // Add padding *after*
      }
      

      // === 10. CONCLUSION ============================================
      // --- Check for page break before starting conclusion ---
      cursor = checkPageBreak(cursor, 100); 
      // Note: If insights section is long, this might be on a new page already.
      // If the *last* insight block caused a page break, we need to add a header.
      // This is complex. Let's assume `addSectionHeader` is on a new page if needed.
      
      doc.addPage(); // Force conclusion to a new page for clean layout
      cursor = pageMargin + 10;
      cursor = addSectionHeader("CONCLUSION", cursor);

      const overallPerformance = metrics.healthScore > 75 ? 'Good' : metrics.healthScore > 50 ? 'Moderate' : 'Poor';
      const topInsight = localInsights[0] || { title: "N/A", description: "Review overall business goals." };
      
      doc.setFont(FONT_BODY, "normal");
      doc.setFontSize(11);
      doc.text(`• Overall business performance: ${overallPerformance}`, pageMargin, cursor);
      cursor += 7;
      doc.text(`• Key focus area for next quarter: ${topInsight.title}`, pageMargin, cursor);
      cursor += 7;
      doc.text("• Recommended actions:", pageMargin, cursor);
      cursor += 7;

      doc.setFont(FONT_BODY, "normal");
      doc.setTextColor(COLOR_SUBTEXT);
      const recommendations = localInsights.map(ins => ins.description);
      for (let i = 0; i < 3 && i < recommendations.length; i++) {
        const splitRec = doc.splitTextToSize(`   ${i + 1}. ${recommendations[i]}`, pageWidth - pageMargin * 2 - 5);
        cursor = checkPageBreak(cursor, (splitRec.length * 5) + 2); // Check for each recommendation
        doc.text(splitRec, pageMargin, cursor);
        cursor += (splitRec.length * 5) + 2;
      }

      // --- FINAL STEP: ADD FOOTERS & SAVE ---
      addPageFooter(doc);
      doc.save(`LynqIQ_Report_${new Date().toISOString().split('T')[0]}.pdf`)

    // --- FIX: Corrected catch block syntax ---
    } catch (err: any) {
      console.error("Error generating PDF:", err)
      // --- FIX: Use aiError to display the error, not the 'error' variable ---
      setAiError(`Failed to generate report: ${err.message}`)
    } finally {
      setPdfLoading(false)
    }
  }


  return (
    <Card className="w-full max-w-lg">
      <CardHeader>
        <div className="flex items-center gap-3">
            <FileText className="h-6 w-6 text-primary" />
            <div>
              <CardTitle>Premium Business Report</CardTitle>
              <CardDescription>Generate a multi-page PDF with business insights</CardDescription>
            </div>
          </div>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* --- STEP 1: AI SUMMARY --- */}
        <div className="space-y-3">
          <label className="font-semibold text-sm">Step 1: Generate Summary</label>
          <p className="text-sm text-muted-foreground">
            Click to generate an executive summary based on your current data.
          </p>
          <Button onClick={handleGenerateSummary} disabled={summaryLoading} className="w-full gap-2">
            {summaryLoading ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin" />
                Analyzing Data...
              </>
            ) : (
              <>
                <Sparkles className="h-4 w-4" />
                Generate Summary
              </>
            )}
          </Button>
          
          {aiError && (
            <div className="p-3 rounded-md bg-destructive/10 text-destructive text-sm flex items-center gap-2">
              <AlertTriangle className="h-4 w-4" />
              <p className="break-all">{aiError}</p>
            </div>
          )}
          
          {aiSummary && (
            <Textarea
              className="mt-2 h-36"
              value={aiSummary}
              readOnly
              placeholder="Summary will appear here..."
            />
          )}
        </div>
        
        {/* --- STEP 2: DOWNLOAD PDF --- */}
        <div className="space-y-3">
          <label className="font-semibold text-sm">Step 2: Download PDF Report</label>
          <p className="text-sm text-muted-foreground">
            Once the summary is generated, you can download the full premium report.
          </p>
          <Button 
            onClick={generatePDF} 
            disabled={!aiSummary || pdfLoading || summaryLoading} 
            className="w-full gap-2"
          >
            {pdfLoading ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin" />
                Building PDF...
              </>
            ) : (
              <>
                <Download className="h-4 w-4" />
                Download Premium PDF
              </>
            )}
          </Button>
        </div>

      </CardContent>
    </Card>
  )
}

// --- This is the local function used instead of the API ---
function generateRecommendations(
  metrics: DashboardMetrics,
  sales: Sale[],
  costs: Cost[],
  products: Product[],
  customers: Customer[],
): string[] {
  const recommendations: string[] = []
  
  if (!metrics) return ["No metrics available to generate recommendations."];

  // Profit recommendations
  if (metrics.netProfit < 0) {
    recommendations.push("URGENT: Business is operating at a loss. Reduce expenses immediately or increase prices.")
  } else if (metrics.profitMargin < 10) {
    recommendations.push("Profit margin is below 10%. Consider pricing optimization or cost reduction strategies.")
  } else if (metrics.profitMargin > 30) {
    recommendations.push("Strong profit margins. Consider reinvesting in business growth and marketing.")
  }

  // Revenue recommendations
  if (sales.filter((s) => s.status === "completed").length < 10) {
    recommendations.push("Build sales momentum. Focus on customer acquisition and marketing campaigns.")
  } else if (sales.filter((s) => s.status === "completed").length > 100) {
    recommendations.push("Strong sales performance. Optimize operations to maintain quality while scaling.")
  }

  // Expense recommendations
  if (metrics.totalRevenue > 0) {
    const expenseRatio = metrics.totalExpenses / metrics.totalRevenue
    if (expenseRatio > 0.6) {
      recommendations.push("Expenses are too high relative to revenue. Audit all spending categories for optimization.")
    } else if (expenseRatio < 0.3) {
      recommendations.push("Low expense ratio indicates efficiency. Ensure you're not under-investing in growth.")
    }
  } else if (metrics.totalExpenses > 0) {
      recommendations.push("You have expenses but no revenue. Investigate revenue generation immediately.")
  }

  // Customer recommendations
  const totalCustomers = customers.length
  if (totalCustomers > 0) {
      const repeatCustomers = customers.filter((c: Customer) => c.total_orders > 1).length
      // FIX: Avoid division by zero if totalCustomers is 0
      const retentionRate = totalCustomers > 0 ? (repeatCustomers / totalCustomers) : 0;
      if (retentionRate < 0.3) {
          recommendations.push("Low customer retention rate. Implement loyalty programs and improve customer experience.")
      } else if (retentionRate > 0.6) {
          recommendations.push("Excellent customer loyalty. Leverage this for upselling and premium offerings.")
      }
  } else {
      recommendations.push("No customer data available. Focus on acquiring your first customers.")
  }

  // Product recommendations
  const lowMarginProducts = products.filter((p: Product) => {
    if (p.sell_price === 0) return false;
    const margin = ((p.sell_price - p.cost_price) / p.sell_price) * 100
    return margin < 15
  })

  if (lowMarginProducts.length > 0) {
    recommendations.push(
      `Review pricing strategy for ${lowMarginProducts.length} low-margin products. Consider price increases or bundling.`,
    )
  }
  
  if (recommendations.length === 0) {
    return ["Business data looks stable. Continue monitoring key metrics and customer feedback."]
  }

  return recommendations
}
